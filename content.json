{"meta":{"title":"人生如逆旅，我亦是行人","subtitle":"放弃不难，但坚持一定很酷。","description":"编程、算法","author":"行息衍","url":"rsrnlwysxr.xyz","root":"/"},"pages":[{"title":"bye","date":"2019-06-07T17:02:01.000Z","updated":"2019-06-07T17:02:01.893Z","comments":true,"path":"bye/index.html","permalink":"rsrnlwysxr.xyz/bye/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-06-07T15:59:27.778Z","updated":"2019-06-07T15:59:27.778Z","comments":true,"path":"categories/index.html","permalink":"rsrnlwysxr.xyz/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-06-07T15:59:49.576Z","updated":"2019-06-07T15:59:49.576Z","comments":true,"path":"tags/index.html","permalink":"rsrnlwysxr.xyz/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-06-07T15:59:06.263Z","updated":"2019-06-07T15:59:06.263Z","comments":true,"path":"about/index.html","permalink":"rsrnlwysxr.xyz/about/index.html","excerpt":"","text":""}],"posts":[{"title":"hello world","slug":"hello-world","date":"2019-06-07T16:33:06.000Z","updated":"2019-06-07T16:33:06.762Z","comments":true,"path":"uncategorized/hello-world","link":"","permalink":"rsrnlwysxr.xyz/uncategorized/hello-world","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解二分查找","slug":"理解二分查找","date":"2019-06-07T15:03:41.000Z","updated":"2019-06-07T16:01:05.211Z","comments":true,"path":"算法/理解二分查找","link":"","permalink":"rsrnlwysxr.xyz/算法/理解二分查找","excerpt":"","text":"何为二分查找法以下来自Wiki 在计算机科学中，二分搜索（英语：binary search），也称折半搜索（英语：half-interval search、对数搜索（英语：logarithmic search，是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 二分查找法的使用计算机世界里,快速查找是一个非常重要的话题，二分查找作为基础且重要的查找方法，值得深入学习。 使用二分查找的要点： 时间复杂度：$O(log~n)$，原因在于每次把搜索区域减少一半 空间复杂度：$O(1)$ 使用条件：有序数组 C++中的二分查找法头文件： #include 主要使用的两个函数： lower_bound(first, last, key) upper_bound(first, last, key) 要说明的是，在有关数组界限中，一般使用左闭右开的原则，即(,] 左闭右开原则大多数有关界限的问题，计算机世界中大多会使用左闭右开的原则，其原因归结于下： 上下界之差为元素个数 易于表现两个相邻区间，前一区间的下界，即为后一区间的上界 易于表达空集，上界不会大于下界 lower_bound返回值说明 lower_bound返回值ret与key的关系: $ret \\ge key$ upper_bound返回值说明 lower_bound返回值ret与key的关系: $ret \\gt key$ 使用Python实现lower_bound()丑陋实现1234567891011121314151617181920212223242526272829def lower_bound(sublist, key): \"\"\" 二分查找 :param sublist: 有序序列 :param key: 需要查找的值 :return: &gt;= key \"\"\" l, r = 0, len(sublist) while l &lt; r: # 根据左闭右开原则, l &lt; r 表示还有区域可搜索 # m = (l + r) // 2 存在溢出可能 m = l + (r - l) // 2 # 若搜索区域为偶数,则m中间靠右,即偏大 # 若搜索区域为奇数,则m中间 if sublist[m] &gt; key: # key在sublist[m]的左侧 r = m elif sublist[m] &lt; key: # key 在sublist[m]的右侧 l = m + 1 # 左闭右开区间, m索引已经考虑,不符合,即不在搜索区域内 else: # 相等下,遍历左侧搜索区域,该步骤可能会提高时间复杂度 for i in range(m - 1, l - 1, -1): if sublist[i] != key: return i + 1 # 出循环条件 l == r, 意味没有找到 if l &lt; len(sublist) and sublist[l] &lt; key: l += 1 return l 优化实现以上的实现,是最直观的实现方法,但非常冗长. 关键点: 如果key在数组中大量重复,会严重降低算法复杂度 最后返回值处理并不优雅,没有充分考虑到各种每次所选择的中间值(偶数情况)带来的问题 关键点1的解决： 应该依旧使用二分查找在剩下的区域中查找，从而避免算法退化 关键点2的解决： 考虑一种情况,key值不在数组中. 如果进行二分搜索,搜索范围应该是: …-&gt;4-&gt;2-&gt;1 考虑4个元素情况下的一些情形（未列举完全）: 如图所示,黄色为本次循环的middle值,即所考察的值。而红色为key本该在的位置，箭头为最终指向的返回值。 通过图发现，每次返回的值与key的大小关系不固定。 而最终返回值期望是大于或等于key的值。 原因在于：如果为偶数元素个数情况下，small，(middle)， big，在这次循环中，会选择big，从而导致大值被排除，剩下较小值，不满足返回条件 综上，代码修改如下： 12345678910111213141516def lower_bound(sublist, key): \"\"\" 二分查找 :param sublist: 有序序列 :param key: 需要查找的值 :return: &gt;= key \"\"\" l, r = 0, len(sublist) while l &lt; r: m = l + (r - l - 1) // 2 # 选择靠左的值 if sublist[m] &gt;= key: # 在等于的情况下,考虑重复元素,要依旧在左侧寻找key,因此设置右界限为m r = m else: l = m + 1 return r 结尾曾经以为二分查找算法非常简单，但通过深入学习优秀的源码，以及自己动手，才发现并没有想象中的那么简单，想要写出优雅的算法代码，确实是需要多思考多动手的。","categories":[{"name":"算法","slug":"算法","permalink":"rsrnlwysxr.xyz/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"rsrnlwysxr.xyz/tags/算法/"},{"name":"二分查找","slug":"二分查找","permalink":"rsrnlwysxr.xyz/tags/二分查找/"}]}]}